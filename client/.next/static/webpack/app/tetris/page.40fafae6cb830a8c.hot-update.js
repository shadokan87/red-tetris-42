"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tetris/page",{

/***/ "(app-pages-browser)/./src/app/tetris/tetris.js":
/*!**********************************!*\
  !*** ./src/app/tetris/tetris.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tetris: function() { return /* binding */ Tetris; },\n/* harmony export */   TetrominoDispenser: function() { return /* binding */ TetrominoDispenser; }\n/* harmony export */ });\n// const tetrominoSequence = [];\n// // keep track of what is in every cell of the game using a 2d array\n// // tetris playfield is 10x20, with a few rows offscreen\n// const playfield = [];\n// // populate the empty state\n// for (let row = -2; row < 20; row++) {\n//   playfield[row] = [];\n//   for (let col = 0; col < 10; col++) {\n//     playfield[row][col] = 0;\n//   }\n// }\n// tetris.js?87f6:252 Uncaught TypeError: Cannot read properties of undefined (reading '0')\n//     at loop (webpack-internal:///(app-pages-browser)/./src/app/tetris/tetris.js:251:35)\n// color of each tetromino\nconst colors = {\n    I: \"cyan\",\n    O: \"yellow\",\n    T: \"purple\",\n    S: \"green\",\n    Z: \"red\",\n    J: \"blue\",\n    L: \"orange\"\n};\nconst initPlayField = ()=>{\n    let result = [];\n    for(let row = -2; row < 20; row++){\n        result[row] = [];\n        for(let col = 0; col < 10; col++){\n            result[row][col] = 0;\n        }\n    }\n    return result;\n};\n/**\n * Class representing a Tetromino Dispenser.\n * @param {function} callback - The function to call when a sequence is generated. This callback function is necessary to synchronize tetrominos between two players.\n */ class TetrominoDispenser {\n    /**\n   * Get a random integer between min and max.\n   * @param {number} min - The minimum value.\n   * @param {number} max - The maximum value.\n   * @return {number} A random integer.\n   */ getRandomInt(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    /**\n   * Generate a sequence of Tetrominos.\n   * @return {Array} The generated sequence.\n   */ generateSequence() {\n        const sequence = [\n            \"I\",\n            \"J\",\n            \"L\",\n            \"O\",\n            \"S\",\n            \"T\",\n            \"Z\"\n        ];\n        let result = [];\n        while(sequence.length){\n            const rand = this.getRandomInt(0, sequence.length - 1);\n            const name = sequence.splice(rand, 1)[0];\n            result.push(name);\n        }\n        return result;\n    }\n    /**\n   * Dispense a sequence of Tetrominos.\n   * @return {TetrominoDispenser} The Tetromino Dispenser instance.\n   */ async dispense() {\n        const sequence = this.generateSequence();\n        this.callback(sequence);\n        return sequence;\n    }\n    /**\n   * Create a Tetromino Dispenser.\n   * @param {function} callback - The function to call when a sequence is generated.\n   */ constructor(callback){\n        this.callback = callback;\n        return this;\n    }\n}\nconst fps = 30;\n/**\n * Class representing a Tetris game.\n * @param {function} onGameOver - The function to call when the game is over.\n * @param {function} onDrawing - The function to call when drawing the game.\n */ class Tetris {\n    setTetrominoDispenser(dispenser) {\n        this.tetrominoDispenser = dispenser;\n        return this;\n    }\n    RegisterKeyStroke(key) {\n        this.keyStroke = [\n            ...this.keyStroke,\n            key\n        ];\n    }\n    ExecuteKeyStroke() {\n        if (!this.keyStroke.length) return;\n        console.log(\"need to execute\", this.keyStroke);\n        const key = this.keyStroke.pop();\n        switch(key){\n            case \"ArrowLeft\":\n            case \"ArrowRight\":\n                const col = key === \"ArrowLeft\" ? this.tetromino.col - 1 : this.tetromino.col + 1;\n                if (this.isValidMove(this.tetromino.matrix, this.tetromino.row, col)) {\n                    this.tetromino.col = col;\n                }\n                break;\n            case \"ArrowUp\":\n                const matrix = this.rotate(this.tetromino.matrix);\n                if (this.isValidMove(matrix, this.tetromino.row, this.tetromino.col)) {\n                    this.tetromino.matrix = matrix;\n                }\n                break;\n            case \"ArrowDown\":\n                const row = this.tetromino.row + 1;\n                if (!this.isValidMove(this.tetromino.matrix, row, this.tetromino.col)) {\n                    this.tetromino.row = row - 1;\n                    this.placetetromino();\n                    return;\n                }\n                this.tetromino.row = row;\n                break;\n            default:\n                break;\n        }\n    // console.log(\"execute key: \" + key);\n    }\n    startGame() {\n        this.playfield = initPlayField();\n        this.tetromino = this.getNextTetromino();\n        this.intervalIds = [\n            setInterval(()=>this.loop(), 1000 / fps),\n            setInterval(()=>this.ExecuteKeyStroke(), 1000 / (fps * 2))\n        ];\n        return this;\n    }\n    stopGame() {\n        if (this.intervalIds[0] != -1) return -1;\n        this.intervalIds.forEach((id)=>clearInterval(id));\n    }\n    appendSequence(sequence) {\n        this.tetrominoSequence = [\n            ...this.tetrominoSequence,\n            ...sequence\n        ];\n    }\n    getNextTetromino() {\n        if (this.tetrominoSequence.length === 0) {\n            this.tetrominoDispenser.dispense();\n        }\n        const name = this.tetrominoSequence.pop();\n        const matrix = this.tetrominos[name];\n        const col = this.playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);\n        const row = name === \"I\" ? -1 : -2;\n        return {\n            name: name,\n            matrix: matrix,\n            row: row,\n            col: col\n        };\n    }\n    // rotate an NxN matrix 90deg\n    // @see https://codereview.stackexchange.com/a/186834\n    rotate(matrix) {\n        const N = matrix.length - 1;\n        const result = matrix.map((row, i)=>row.map((val, j)=>matrix[N - j][i]));\n        return result;\n    }\n    // check to see if the new matrix/row/col is valid\n    isValidMove(matrix, cellRow, cellCol) {\n        for(let row = 0; row < matrix.length; row++){\n            for(let col = 0; col < matrix[row].length; col++){\n                if (matrix[row][col] && // outside the game bounds\n                (cellCol + col < 0 || cellCol + col >= this.playfield[0].length || cellRow + row >= this.playfield.length || // collides with another piece\n                this.playfield[cellRow + row][cellCol + col])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    placetetromino() {\n        for(let row = 0; row < this.tetromino.matrix.length; row++){\n            for(let col = 0; col < this.tetromino.matrix[row].length; col++){\n                if (this.tetromino.matrix[row][col]) {\n                    // game over if piece has any part offscreen\n                    if (this.tetromino.row + row < 0) {\n                        this.stopGame();\n                        return this.onGameOver();\n                    }\n                    this.playfield[this.tetromino.row + row][this.tetromino.col + col] = this.tetromino.name;\n                }\n            }\n        }\n        // check for line clears starting from the bottom and working our way up\n        for(let row = this.playfield.length - 1; row >= 0;){\n            if (this.playfield[row].every((cell)=>!!cell)) {\n                // drop every row above this one\n                for(let r = row; r >= 0; r--){\n                    for(let c = 0; c < this.playfield[r].length; c++){\n                        this.playfield[r][c] = this.playfield[r - 1][c];\n                    }\n                }\n            } else {\n                row--;\n            }\n        }\n        this.tetromino = this.getNextTetromino();\n    }\n    loop() {\n        this.onTick();\n        // context.clearRect(0, 0, canvas.width, canvas.height);\n        // draw the this.playfield\n        for(let row = 0; row < 20; row++){\n            for(let col = 0; col < 10; col++){\n                if (this.playfield[row][col]) {\n                    const name = this.playfield[row][col];\n                    //   context.fillStyle = colors[name];\n                    // drawing 1 px smaller than the grid creates a grid effect\n                    this.onDrawing({\n                        row: row + 1,\n                        col: col + 1,\n                        color: colors[name]\n                    });\n                //   drawPieceAt(row + 1, col + 1, colors[name]);\n                //   context.fillRect(col * grid, row * grid, grid - 1, grid - 1);\n                }\n            }\n        }\n        // draw the active this.tetromino\n        if (this.tetromino) {\n            // console.log(\"!draw\" + JSON.stringify(this.tetromino));\n            // this.tetromino falls every 35 frames\n            if (++this.count > 35) {\n                this.tetromino.row++;\n                this.count = 0;\n                // place piece if it runs into anything\n                if (!this.isValidMove(this.tetromino.matrix, this.tetromino.row, this.tetromino.col)) {\n                    this.tetromino.row--;\n                    this.placetetromino();\n                }\n            }\n            function isHidden(row, col) {\n                // Define the grid boundaries\n                const minRow = 0;\n                const maxRow = 19;\n                const minCol = 0;\n                const maxCol = 9;\n                // Check if the current piece's row and col are outside the boundaries\n                if (row < minRow || row > maxRow || col < minCol || col > maxCol) {\n                    return true;\n                }\n                return false;\n            }\n            function isInsideOfGameGrid(row, col) {\n                // Define the grid boundaries\n                const minRow = 0;\n                const maxRow = 19; // As the grid's height is 20\n                const minCol = 0;\n                const maxCol = 9; // As the grid's width is 10\n                // Check if the current piece's row and col are inside the boundaries\n                return row >= minRow && row <= maxRow && col >= minCol && col <= maxCol;\n            }\n            for(let row = 0; row < this.tetromino.matrix.length; row++){\n                for(let col = 0; col < this.tetromino.matrix[row].length; col++){\n                    if (this.tetromino.matrix[row][col]) {\n                        const display = isInsideOfGameGrid(this.tetromino.row + row, this.tetromino.col + col);\n                        if (!display) continue;\n                        this.onDrawing({\n                            row: this.tetromino.row + row + 1,\n                            col: this.tetromino.col + col + 1,\n                            color: colors[this.tetromino.name]\n                        });\n                    // drawPieceAt(\n                    //   this.tetromino.row + row + 1,\n                    //   this.tetromino.col + col + 1,\n                    //   colors[this.tetromino.name]\n                    // );\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Create a Tetris game.\n   * @param {function} onGameOver - The function to call when the game is over.\n   * @param {function} onDrawing - The function to call when drawing the game.\n   */ constructor(onGameOver, onDrawing, onTick){\n        this.tetrominos = {\n            I: [\n                [\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    1,\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            J: [\n                [\n                    1,\n                    0,\n                    0\n                ],\n                [\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            L: [\n                [\n                    0,\n                    0,\n                    1\n                ],\n                [\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            O: [\n                [\n                    1,\n                    1\n                ],\n                [\n                    1,\n                    1\n                ]\n            ],\n            S: [\n                [\n                    0,\n                    1,\n                    1\n                ],\n                [\n                    1,\n                    1,\n                    0\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            Z: [\n                [\n                    1,\n                    1,\n                    0\n                ],\n                [\n                    0,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            T: [\n                [\n                    0,\n                    1,\n                    0\n                ],\n                [\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ]\n        };\n        this.keyStroke = [];\n        this.tetrominoSequence = [];\n        this.intervalIds = -1;\n        this.count = 0;\n        console.log(\"++++++++++ Tetris init\");\n        this.onGameOver = onGameOver;\n        this.onDrawing = onDrawing;\n        this.onTick = onTick;\n        return this;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdGV0cmlzL3RldHJpcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGdDQUFnQztBQUVoQyxzRUFBc0U7QUFDdEUsMERBQTBEO0FBQzFELHdCQUF3QjtBQUV4Qiw4QkFBOEI7QUFDOUIsd0NBQXdDO0FBQ3hDLHlCQUF5QjtBQUV6Qix5Q0FBeUM7QUFDekMsK0JBQStCO0FBQy9CLE1BQU07QUFDTixJQUFJO0FBRUosMkZBQTJGO0FBQzNGLDBGQUEwRjtBQUUxRiwwQkFBMEI7QUFDMUIsTUFBTUEsU0FBUztJQUNiQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0FBQ0w7QUFFQSxNQUFNQyxnQkFBZ0I7SUFDcEIsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSyxJQUFJQyxNQUFNLENBQUMsR0FBR0EsTUFBTSxJQUFJQSxNQUFPO1FBQ2xDRCxNQUFNLENBQUNDLElBQUksR0FBRyxFQUFFO1FBRWhCLElBQUssSUFBSUMsTUFBTSxHQUFHQSxNQUFNLElBQUlBLE1BQU87WUFDakNGLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDckI7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDTSxNQUFNRztJQVNYOzs7OztHQUtDLEdBQ0RDLGFBQWFDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO1FBQ3JCRCxNQUFNRSxLQUFLQyxJQUFJLENBQUNIO1FBQ2hCQyxNQUFNQyxLQUFLRSxLQUFLLENBQUNIO1FBRWpCLE9BQU9DLEtBQUtFLEtBQUssQ0FBQ0YsS0FBS0csTUFBTSxLQUFNSixDQUFBQSxNQUFNRCxNQUFNLE1BQU1BO0lBQ3ZEO0lBQ0E7OztHQUdDLEdBQ0RNLG1CQUFtQjtRQUNqQixNQUFNQyxXQUFXO1lBQUM7WUFBSztZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUs7U0FBSTtRQUNwRCxJQUFJWixTQUFTLEVBQUU7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LElBQUksQ0FBQzJCLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDTSxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0QsTUFBTSxHQUFHQTtRQUNkLE9BQU8sSUFBSTtJQUNiO0FBZ1BGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvdGV0cmlzL3RldHJpcy5qcz84N2Y2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbnN0IHRldHJvbWlub1NlcXVlbmNlID0gW107XG5cbi8vIC8vIGtlZXAgdHJhY2sgb2Ygd2hhdCBpcyBpbiBldmVyeSBjZWxsIG9mIHRoZSBnYW1lIHVzaW5nIGEgMmQgYXJyYXlcbi8vIC8vIHRldHJpcyBwbGF5ZmllbGQgaXMgMTB4MjAsIHdpdGggYSBmZXcgcm93cyBvZmZzY3JlZW5cbi8vIGNvbnN0IHBsYXlmaWVsZCA9IFtdO1xuXG4vLyAvLyBwb3B1bGF0ZSB0aGUgZW1wdHkgc3RhdGVcbi8vIGZvciAobGV0IHJvdyA9IC0yOyByb3cgPCAyMDsgcm93KyspIHtcbi8vICAgcGxheWZpZWxkW3Jvd10gPSBbXTtcblxuLy8gICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCAxMDsgY29sKyspIHtcbi8vICAgICBwbGF5ZmllbGRbcm93XVtjb2xdID0gMDtcbi8vICAgfVxuLy8gfVxuXG4vLyB0ZXRyaXMuanM/ODdmNjoyNTIgVW5jYXVnaHQgVHlwZUVycm9yOiBDYW5ub3QgcmVhZCBwcm9wZXJ0aWVzIG9mIHVuZGVmaW5lZCAocmVhZGluZyAnMCcpXG4vLyAgICAgYXQgbG9vcCAod2VicGFjay1pbnRlcm5hbDovLy8oYXBwLXBhZ2VzLWJyb3dzZXIpLy4vc3JjL2FwcC90ZXRyaXMvdGV0cmlzLmpzOjI1MTozNSlcblxuLy8gY29sb3Igb2YgZWFjaCB0ZXRyb21pbm9cbmNvbnN0IGNvbG9ycyA9IHtcbiAgSTogXCJjeWFuXCIsXG4gIE86IFwieWVsbG93XCIsXG4gIFQ6IFwicHVycGxlXCIsXG4gIFM6IFwiZ3JlZW5cIixcbiAgWjogXCJyZWRcIixcbiAgSjogXCJibHVlXCIsXG4gIEw6IFwib3JhbmdlXCIsXG59O1xuXG5jb25zdCBpbml0UGxheUZpZWxkID0gKCkgPT4ge1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IHJvdyA9IC0yOyByb3cgPCAyMDsgcm93KyspIHtcbiAgICByZXN1bHRbcm93XSA9IFtdO1xuXG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgMTA7IGNvbCsrKSB7XG4gICAgICByZXN1bHRbcm93XVtjb2xdID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVGV0cm9taW5vIERpc3BlbnNlci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIHNlcXVlbmNlIGlzIGdlbmVyYXRlZC4gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgdG8gc3luY2hyb25pemUgdGV0cm9taW5vcyBiZXR3ZWVuIHR3byBwbGF5ZXJzLlxuICovXG5leHBvcnQgY2xhc3MgVGV0cm9taW5vRGlzcGVuc2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRldHJvbWlubyBEaXNwZW5zZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIHNlcXVlbmNlIGlzIGdlbmVyYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIC0gVGhlIG1pbmltdW0gdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBUaGUgbWF4aW11bSB2YWx1ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBBIHJhbmRvbSBpbnRlZ2VyLlxuICAgKi9cbiAgZ2V0UmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gICAgbWluID0gTWF0aC5jZWlsKG1pbik7XG4gICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc2VxdWVuY2Ugb2YgVGV0cm9taW5vcy5cbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBnZW5lcmF0ZVNlcXVlbmNlKCkge1xuICAgIGNvbnN0IHNlcXVlbmNlID0gW1wiSVwiLCBcIkpcIiwgXCJMXCIsIFwiT1wiLCBcIlNcIiwgXCJUXCIsIFwiWlwiXTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCByYW5kID0gdGhpcy5nZXRSYW5kb21JbnQoMCwgc2VxdWVuY2UubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBuYW1lID0gc2VxdWVuY2Uuc3BsaWNlKHJhbmQsIDEpWzBdO1xuICAgICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIERpc3BlbnNlIGEgc2VxdWVuY2Ugb2YgVGV0cm9taW5vcy5cbiAgICogQHJldHVybiB7VGV0cm9taW5vRGlzcGVuc2VyfSBUaGUgVGV0cm9taW5vIERpc3BlbnNlciBpbnN0YW5jZS5cbiAgICovXG4gIGFzeW5jIGRpc3BlbnNlKCkge1xuICAgIGNvbnN0IHNlcXVlbmNlID0gdGhpcy5nZW5lcmF0ZVNlcXVlbmNlKCk7XG4gICAgdGhpcy5jYWxsYmFjayhzZXF1ZW5jZSk7XG4gICAgcmV0dXJuIHNlcXVlbmNlO1xuICB9XG59XG5cbmNvbnN0IGZwcyA9IDMwO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBUZXRyaXMgZ2FtZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uR2FtZU92ZXIgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBnYW1lIGlzIG92ZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkRyYXdpbmcgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRyYXdpbmcgdGhlIGdhbWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXRyaXMge1xuICB0ZXRyb21pbm9zID0ge1xuICAgIEk6IFtcbiAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgIFsxLCAxLCAxLCAxXSxcbiAgICAgIFswLCAwLCAwLCAwXSxcbiAgICAgIFswLCAwLCAwLCAwXSxcbiAgICBdLFxuICAgIEo6IFtcbiAgICAgIFsxLCAwLCAwXSxcbiAgICAgIFsxLCAxLCAxXSxcbiAgICAgIFswLCAwLCAwXSxcbiAgICBdLFxuICAgIEw6IFtcbiAgICAgIFswLCAwLCAxXSxcbiAgICAgIFsxLCAxLCAxXSxcbiAgICAgIFswLCAwLCAwXSxcbiAgICBdLFxuICAgIE86IFtcbiAgICAgIFsxLCAxXSxcbiAgICAgIFsxLCAxXSxcbiAgICBdLFxuICAgIFM6IFtcbiAgICAgIFswLCAxLCAxXSxcbiAgICAgIFsxLCAxLCAwXSxcbiAgICAgIFswLCAwLCAwXSxcbiAgICBdLFxuICAgIFo6IFtcbiAgICAgIFsxLCAxLCAwXSxcbiAgICAgIFswLCAxLCAxXSxcbiAgICAgIFswLCAwLCAwXSxcbiAgICBdLFxuICAgIFQ6IFtcbiAgICAgIFswLCAxLCAwXSxcbiAgICAgIFsxLCAxLCAxXSxcbiAgICAgIFswLCAwLCAwXSxcbiAgICBdLFxuICB9O1xuICBvbkdhbWVPdmVyO1xuICBvbkRyYXdpbmc7XG4gIGtleVN0cm9rZSA9IFtdO1xuICBvblRpY2s7XG4gIHBsYXlmaWVsZDtcbiAgdGV0cm9taW5vU2VxdWVuY2UgPSBbXTtcbiAgdGV0cm9taW5vO1xuICBpbnRlcnZhbElkcyA9IC0xO1xuICBjb3VudCA9IDA7XG4gIHRldHJvbWlub0Rpc3BlbnNlcjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV0cmlzIGdhbWUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uR2FtZU92ZXIgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBnYW1lIGlzIG92ZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uRHJhd2luZyAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZHJhd2luZyB0aGUgZ2FtZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9uR2FtZU92ZXIsIG9uRHJhd2luZywgb25UaWNrKSB7XG4gICAgY29uc29sZS5sb2coXCIrKysrKysrKysrIFRldHJpcyBpbml0XCIpO1xuICAgIHRoaXMub25HYW1lT3ZlciA9IG9uR2FtZU92ZXI7XG4gICAgdGhpcy5vbkRyYXdpbmcgPSBvbkRyYXdpbmc7XG4gICAgdGhpcy5vblRpY2sgPSBvblRpY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRUZXRyb21pbm9EaXNwZW5zZXIoZGlzcGVuc2VyKSB7XG4gICAgdGhpcy50ZXRyb21pbm9EaXNwZW5zZXIgPSBkaXNwZW5zZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBSZWdpc3RlcktleVN0cm9rZShrZXkpIHtcbiAgICB0aGlzLmtleVN0cm9rZSA9IFsuLi50aGlzLmtleVN0cm9rZSwga2V5XTtcbiAgfVxuXG4gIEV4ZWN1dGVLZXlTdHJva2UoKSB7XG4gICAgaWYgKCF0aGlzLmtleVN0cm9rZS5sZW5ndGgpIHJldHVybjtcbiAgICBjb25zb2xlLmxvZyhcIm5lZWQgdG8gZXhlY3V0ZVwiLCB0aGlzLmtleVN0cm9rZSk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5rZXlTdHJva2UucG9wKCk7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIGNvbnN0IGNvbCA9XG4gICAgICAgICAga2V5ID09PSBcIkFycm93TGVmdFwiID8gdGhpcy50ZXRyb21pbm8uY29sIC0gMSA6IHRoaXMudGV0cm9taW5vLmNvbCArIDE7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRNb3ZlKHRoaXMudGV0cm9taW5vLm1hdHJpeCwgdGhpcy50ZXRyb21pbm8ucm93LCBjb2wpKSB7XG4gICAgICAgICAgdGhpcy50ZXRyb21pbm8uY29sID0gY29sO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdGhpcy5yb3RhdGUodGhpcy50ZXRyb21pbm8ubWF0cml4KTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZE1vdmUobWF0cml4LCB0aGlzLnRldHJvbWluby5yb3csIHRoaXMudGV0cm9taW5vLmNvbCkpIHtcbiAgICAgICAgICB0aGlzLnRldHJvbWluby5tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGNvbnN0IHJvdyA9IHRoaXMudGV0cm9taW5vLnJvdyArIDE7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkTW92ZSh0aGlzLnRldHJvbWluby5tYXRyaXgsIHJvdywgdGhpcy50ZXRyb21pbm8uY29sKSkge1xuICAgICAgICAgIHRoaXMudGV0cm9taW5vLnJvdyA9IHJvdyAtIDE7XG4gICAgICAgICAgdGhpcy5wbGFjZXRldHJvbWlubygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRldHJvbWluby5yb3cgPSByb3c7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKFwiZXhlY3V0ZSBrZXk6IFwiICsga2V5KTtcbiAgfVxuXG4gIHN0YXJ0R2FtZSgpIHtcbiAgICB0aGlzLnBsYXlmaWVsZCA9IGluaXRQbGF5RmllbGQoKTtcbiAgICB0aGlzLnRldHJvbWlubyA9IHRoaXMuZ2V0TmV4dFRldHJvbWlubygpO1xuICAgIHRoaXMuaW50ZXJ2YWxJZHMgPSBbXG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLmxvb3AoKSwgMTAwMCAvIGZwcyksXG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLkV4ZWN1dGVLZXlTdHJva2UoKSwgMTAwMCAvIChmcHMgKiAyKSksXG4gICAgXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdG9wR2FtZSgpIHtcbiAgICBpZiAodGhpcy5pbnRlcnZhbElkc1swXSAhPSAtMSkgcmV0dXJuIC0xO1xuICAgIHRoaXMuaW50ZXJ2YWxJZHMuZm9yRWFjaCgoaWQpID0+IGNsZWFySW50ZXJ2YWwoaWQpKTtcbiAgfVxuXG4gIGFwcGVuZFNlcXVlbmNlKHNlcXVlbmNlKSB7XG4gICAgdGhpcy50ZXRyb21pbm9TZXF1ZW5jZSA9IFsuLi50aGlzLnRldHJvbWlub1NlcXVlbmNlLCAuLi5zZXF1ZW5jZV07XG4gIH1cblxuICBnZXROZXh0VGV0cm9taW5vKCkge1xuICAgIGlmICh0aGlzLnRldHJvbWlub1NlcXVlbmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy50ZXRyb21pbm9EaXNwZW5zZXIuZGlzcGVuc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gdGhpcy50ZXRyb21pbm9TZXF1ZW5jZS5wb3AoKTtcbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLnRldHJvbWlub3NbbmFtZV07XG5cbiAgICBjb25zdCBjb2wgPSB0aGlzLnBsYXlmaWVsZFswXS5sZW5ndGggLyAyIC0gTWF0aC5jZWlsKG1hdHJpeFswXS5sZW5ndGggLyAyKTtcblxuICAgIGNvbnN0IHJvdyA9IG5hbWUgPT09IFwiSVwiID8gLTEgOiAtMjtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgbWF0cml4OiBtYXRyaXgsXG4gICAgICByb3c6IHJvdyxcbiAgICAgIGNvbDogY29sLFxuICAgIH07XG4gIH1cblxuICAvLyByb3RhdGUgYW4gTnhOIG1hdHJpeCA5MGRlZ1xuICAvLyBAc2VlIGh0dHBzOi8vY29kZXJldmlldy5zdGFja2V4Y2hhbmdlLmNvbS9hLzE4NjgzNFxuICByb3RhdGUobWF0cml4KSB7XG4gICAgY29uc3QgTiA9IG1hdHJpeC5sZW5ndGggLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1hdHJpeC5tYXAoKHJvdywgaSkgPT5cbiAgICAgIHJvdy5tYXAoKHZhbCwgaikgPT4gbWF0cml4W04gLSBqXVtpXSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGUgbmV3IG1hdHJpeC9yb3cvY29sIGlzIHZhbGlkXG4gIGlzVmFsaWRNb3ZlKG1hdHJpeCwgY2VsbFJvdywgY2VsbENvbCkge1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hdHJpeC5sZW5ndGg7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBtYXRyaXhbcm93XS5sZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtYXRyaXhbcm93XVtjb2xdICYmXG4gICAgICAgICAgLy8gb3V0c2lkZSB0aGUgZ2FtZSBib3VuZHNcbiAgICAgICAgICAoY2VsbENvbCArIGNvbCA8IDAgfHxcbiAgICAgICAgICAgIGNlbGxDb2wgKyBjb2wgPj0gdGhpcy5wbGF5ZmllbGRbMF0ubGVuZ3RoIHx8XG4gICAgICAgICAgICBjZWxsUm93ICsgcm93ID49IHRoaXMucGxheWZpZWxkLmxlbmd0aCB8fFxuICAgICAgICAgICAgLy8gY29sbGlkZXMgd2l0aCBhbm90aGVyIHBpZWNlXG4gICAgICAgICAgICB0aGlzLnBsYXlmaWVsZFtjZWxsUm93ICsgcm93XVtjZWxsQ29sICsgY29sXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwbGFjZXRldHJvbWlubygpIHtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnRldHJvbWluby5tYXRyaXgubGVuZ3RoOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy50ZXRyb21pbm8ubWF0cml4W3Jvd10ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICBpZiAodGhpcy50ZXRyb21pbm8ubWF0cml4W3Jvd11bY29sXSkge1xuICAgICAgICAgIC8vIGdhbWUgb3ZlciBpZiBwaWVjZSBoYXMgYW55IHBhcnQgb2Zmc2NyZWVuXG4gICAgICAgICAgaWYgKHRoaXMudGV0cm9taW5vLnJvdyArIHJvdyA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcEdhbWUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uR2FtZU92ZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBsYXlmaWVsZFt0aGlzLnRldHJvbWluby5yb3cgKyByb3ddW3RoaXMudGV0cm9taW5vLmNvbCArIGNvbF0gPVxuICAgICAgICAgICAgdGhpcy50ZXRyb21pbm8ubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBsaW5lIGNsZWFycyBzdGFydGluZyBmcm9tIHRoZSBib3R0b20gYW5kIHdvcmtpbmcgb3VyIHdheSB1cFxuICAgIGZvciAobGV0IHJvdyA9IHRoaXMucGxheWZpZWxkLmxlbmd0aCAtIDE7IHJvdyA+PSAwOyApIHtcbiAgICAgIGlmICh0aGlzLnBsYXlmaWVsZFtyb3ddLmV2ZXJ5KChjZWxsKSA9PiAhIWNlbGwpKSB7XG4gICAgICAgIC8vIGRyb3AgZXZlcnkgcm93IGFib3ZlIHRoaXMgb25lXG4gICAgICAgIGZvciAobGV0IHIgPSByb3c7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0aGlzLnBsYXlmaWVsZFtyXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZmllbGRbcl1bY10gPSB0aGlzLnBsYXlmaWVsZFtyIC0gMV1bY107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3ctLTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50ZXRyb21pbm8gPSB0aGlzLmdldE5leHRUZXRyb21pbm8oKTtcbiAgfVxuXG4gIGxvb3AoKSB7XG4gICAgdGhpcy5vblRpY2soKTtcbiAgICAvLyBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgLy8gZHJhdyB0aGUgdGhpcy5wbGF5ZmllbGRcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCAyMDsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDEwOyBjb2wrKykge1xuICAgICAgICBpZiAodGhpcy5wbGF5ZmllbGRbcm93XVtjb2xdKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGxheWZpZWxkW3Jvd11bY29sXTtcbiAgICAgICAgICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3JzW25hbWVdO1xuXG4gICAgICAgICAgLy8gZHJhd2luZyAxIHB4IHNtYWxsZXIgdGhhbiB0aGUgZ3JpZCBjcmVhdGVzIGEgZ3JpZCBlZmZlY3RcbiAgICAgICAgICB0aGlzLm9uRHJhd2luZyh7XG4gICAgICAgICAgICByb3c6IHJvdyArIDEsXG4gICAgICAgICAgICBjb2w6IGNvbCArIDEsXG4gICAgICAgICAgICBjb2xvcjogY29sb3JzW25hbWVdLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vICAgZHJhd1BpZWNlQXQocm93ICsgMSwgY29sICsgMSwgY29sb3JzW25hbWVdKTtcbiAgICAgICAgICAvLyAgIGNvbnRleHQuZmlsbFJlY3QoY29sICogZ3JpZCwgcm93ICogZ3JpZCwgZ3JpZCAtIDEsIGdyaWQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyYXcgdGhlIGFjdGl2ZSB0aGlzLnRldHJvbWlub1xuICAgIGlmICh0aGlzLnRldHJvbWlubykge1xuICAgICAgLy8gY29uc29sZS5sb2coXCIhZHJhd1wiICsgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXRyb21pbm8pKTtcbiAgICAgIC8vIHRoaXMudGV0cm9taW5vIGZhbGxzIGV2ZXJ5IDM1IGZyYW1lc1xuICAgICAgaWYgKCsrdGhpcy5jb3VudCA+IDM1KSB7XG4gICAgICAgIHRoaXMudGV0cm9taW5vLnJvdysrO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcblxuICAgICAgICAvLyBwbGFjZSBwaWVjZSBpZiBpdCBydW5zIGludG8gYW55dGhpbmdcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF0aGlzLmlzVmFsaWRNb3ZlKFxuICAgICAgICAgICAgdGhpcy50ZXRyb21pbm8ubWF0cml4LFxuICAgICAgICAgICAgdGhpcy50ZXRyb21pbm8ucm93LFxuICAgICAgICAgICAgdGhpcy50ZXRyb21pbm8uY29sXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnRldHJvbWluby5yb3ctLTtcbiAgICAgICAgICB0aGlzLnBsYWNldGV0cm9taW5vKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNIaWRkZW4ocm93LCBjb2wpIHtcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBncmlkIGJvdW5kYXJpZXNcbiAgICAgICAgY29uc3QgbWluUm93ID0gMDtcbiAgICAgICAgY29uc3QgbWF4Um93ID0gMTk7XG4gICAgICAgIGNvbnN0IG1pbkNvbCA9IDA7XG4gICAgICAgIGNvbnN0IG1heENvbCA9IDk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgcGllY2UncyByb3cgYW5kIGNvbCBhcmUgb3V0c2lkZSB0aGUgYm91bmRhcmllc1xuICAgICAgICBpZiAocm93IDwgbWluUm93IHx8IHJvdyA+IG1heFJvdyB8fCBjb2wgPCBtaW5Db2wgfHwgY29sID4gbWF4Q29sKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSW5zaWRlT2ZHYW1lR3JpZChyb3csIGNvbCkge1xuICAgICAgICAvLyBEZWZpbmUgdGhlIGdyaWQgYm91bmRhcmllc1xuICAgICAgICBjb25zdCBtaW5Sb3cgPSAwO1xuICAgICAgICBjb25zdCBtYXhSb3cgPSAxOTsgLy8gQXMgdGhlIGdyaWQncyBoZWlnaHQgaXMgMjBcbiAgICAgICAgY29uc3QgbWluQ29sID0gMDtcbiAgICAgICAgY29uc3QgbWF4Q29sID0gOTsgLy8gQXMgdGhlIGdyaWQncyB3aWR0aCBpcyAxMFxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHBpZWNlJ3Mgcm93IGFuZCBjb2wgYXJlIGluc2lkZSB0aGUgYm91bmRhcmllc1xuICAgICAgICByZXR1cm4gcm93ID49IG1pblJvdyAmJiByb3cgPD0gbWF4Um93ICYmIGNvbCA+PSBtaW5Db2wgJiYgY29sIDw9IG1heENvbDtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy50ZXRyb21pbm8ubWF0cml4Lmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy50ZXRyb21pbm8ubWF0cml4W3Jvd10ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgIGlmICh0aGlzLnRldHJvbWluby5tYXRyaXhbcm93XVtjb2xdKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5ID0gaXNJbnNpZGVPZkdhbWVHcmlkKFxuICAgICAgICAgICAgICB0aGlzLnRldHJvbWluby5yb3cgKyByb3csXG4gICAgICAgICAgICAgIHRoaXMudGV0cm9taW5vLmNvbCArIGNvbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghZGlzcGxheSkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLm9uRHJhd2luZyh7XG4gICAgICAgICAgICAgIHJvdzogdGhpcy50ZXRyb21pbm8ucm93ICsgcm93ICsgMSxcbiAgICAgICAgICAgICAgY29sOiB0aGlzLnRldHJvbWluby5jb2wgKyBjb2wgKyAxLFxuICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW3RoaXMudGV0cm9taW5vLm5hbWVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBkcmF3UGllY2VBdChcbiAgICAgICAgICAgIC8vICAgdGhpcy50ZXRyb21pbm8ucm93ICsgcm93ICsgMSxcbiAgICAgICAgICAgIC8vICAgdGhpcy50ZXRyb21pbm8uY29sICsgY29sICsgMSxcbiAgICAgICAgICAgIC8vICAgY29sb3JzW3RoaXMudGV0cm9taW5vLm5hbWVdXG4gICAgICAgICAgICAvLyApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImNvbG9ycyIsIkkiLCJPIiwiVCIsIlMiLCJaIiwiSiIsIkwiLCJpbml0UGxheUZpZWxkIiwicmVzdWx0Iiwicm93IiwiY29sIiwiVGV0cm9taW5vRGlzcGVuc2VyIiwiZ2V0UmFuZG9tSW50IiwibWluIiwibWF4IiwiTWF0aCIsImNlaWwiLCJmbG9vciIsInJhbmRvbSIsImdlbmVyYXRlU2VxdWVuY2UiLCJzZXF1ZW5jZSIsImxlbmd0aCIsInJhbmQiLCJuYW1lIiwic3BsaWNlIiwicHVzaCIsImRpc3BlbnNlIiwiY2FsbGJhY2siLCJjb25zdHJ1Y3RvciIsImZwcyIsIlRldHJpcyIsInNldFRldHJvbWlub0Rpc3BlbnNlciIsImRpc3BlbnNlciIsInRldHJvbWlub0Rpc3BlbnNlciIsIlJlZ2lzdGVyS2V5U3Ryb2tlIiwia2V5Iiwia2V5U3Ryb2tlIiwiRXhlY3V0ZUtleVN0cm9rZSIsImNvbnNvbGUiLCJsb2ciLCJwb3AiLCJ0ZXRyb21pbm8iLCJpc1ZhbGlkTW92ZSIsIm1hdHJpeCIsInJvdGF0ZSIsInBsYWNldGV0cm9taW5vIiwic3RhcnRHYW1lIiwicGxheWZpZWxkIiwiZ2V0TmV4dFRldHJvbWlubyIsImludGVydmFsSWRzIiwic2V0SW50ZXJ2YWwiLCJsb29wIiwic3RvcEdhbWUiLCJmb3JFYWNoIiwiaWQiLCJjbGVhckludGVydmFsIiwiYXBwZW5kU2VxdWVuY2UiLCJ0ZXRyb21pbm9TZXF1ZW5jZSIsInRldHJvbWlub3MiLCJOIiwibWFwIiwiaSIsInZhbCIsImoiLCJjZWxsUm93IiwiY2VsbENvbCIsIm9uR2FtZU92ZXIiLCJldmVyeSIsImNlbGwiLCJyIiwiYyIsIm9uVGljayIsIm9uRHJhd2luZyIsImNvbG9yIiwiY291bnQiLCJpc0hpZGRlbiIsIm1pblJvdyIsIm1heFJvdyIsIm1pbkNvbCIsIm1heENvbCIsImlzSW5zaWRlT2ZHYW1lR3JpZCIsImRpc3BsYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/tetris/tetris.js\n"));

/***/ })

});