"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/tetris/page",{

/***/ "(app-pages-browser)/./src/app/tetris/tetris.js":
/*!**********************************!*\
  !*** ./src/app/tetris/tetris.js ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tetris: function() { return /* binding */ Tetris; },\n/* harmony export */   TetrominoDispenser: function() { return /* binding */ TetrominoDispenser; }\n/* harmony export */ });\n// color of each tetromino\nconst colors = {\n    I: \"cyan\",\n    O: \"yellow\",\n    T: \"purple\",\n    S: \"green\",\n    Z: \"red\",\n    J: \"blue\",\n    L: \"orange\"\n};\nconst initPlayField = ()=>{\n    let result = [];\n    for(let row = -2; row < 20; row++){\n        result[row] = [];\n        for(let col = 0; col < 10; col++){\n            result[row][col] = 0;\n        }\n    }\n    return result;\n};\n/**\n * Class representing a Tetromino Dispenser.\n * @param {function} callback - The function to call when a sequence is generated. This callback function is necessary to synchronize tetrominos between two players.\n */ class TetrominoDispenser {\n    /**\n   * Get a random integer between min and max.\n   * @param {number} min - The minimum value.\n   * @param {number} max - The maximum value.\n   * @return {number} A random integer.\n   */ getRandomInt(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    /**\n   * Generate a sequence of Tetrominos.\n   * @return {Array} The generated sequence.\n   */ generateSequence() {\n        const sequence = [\n            \"I\",\n            \"J\",\n            \"L\",\n            \"O\",\n            \"S\",\n            \"T\",\n            \"Z\"\n        ];\n        let result = [];\n        while(sequence.length){\n            const rand = this.getRandomInt(0, sequence.length - 1);\n            const name = sequence.splice(rand, 1)[0];\n            result.push(name);\n        }\n        return result;\n    }\n    /**\n   * Dispense a sequence of Tetrominos.\n   * @return {TetrominoDispenser} The Tetromino Dispenser instance.\n   */ async dispense() {\n        const sequence = this.generateSequence();\n        this.callback(sequence);\n        return sequence;\n    }\n    /**\n   * Create a Tetromino Dispenser.\n   * @param {function} callback - The function to call when a sequence is generated.\n   */ constructor(callback){\n        this.callback = callback;\n        return this;\n    }\n}\nconst fps = 30;\n/**\n * Class representing a Tetris game.\n * @param {function} onGameOver - The function to call when the game is over.\n * @param {function} onDrawing - The function to call when drawing the game.\n */ class Tetris {\n    setTetrominoDispenser(dispenser) {\n        this.tetrominoDispenser = dispenser;\n        return this;\n    }\n    RegisterKeyStroke(key) {\n        this.keyStroke = [\n            ...this.keyStroke,\n            key\n        ];\n    }\n    ExecuteKeyStroke() {\n        if (!this.keyStroke.length) return;\n        console.log(\"need to execute\", this.keyStroke);\n        const key = this.keyStroke.pop();\n        switch(key){\n            case \"ArrowLeft\":\n            case \"ArrowRight\":\n                const col = key === \"ArrowLeft\" ? this.tetromino.col - 1 : this.tetromino.col + 1;\n                if (this.isValidMove(this.tetromino.matrix, this.tetromino.row, col)) {\n                    this.tetromino.col = col;\n                }\n                break;\n            case \"ArrowUp\":\n                const matrix = this.rotate(this.tetromino.matrix);\n                if (this.isValidMove(matrix, this.tetromino.row, this.tetromino.col)) {\n                    this.tetromino.matrix = matrix;\n                }\n                break;\n            case \"ArrowDown\":\n                const row = this.tetromino.row + 1;\n                if (!this.isValidMove(this.tetromino.matrix, row, this.tetromino.col)) {\n                    this.tetromino.row = row - 1;\n                    this.placetetromino();\n                    return;\n                }\n                this.tetromino.row = row;\n                break;\n            default:\n                break;\n        }\n    // console.log(\"execute key: \" + key);\n    }\n    startGame() {\n        this.playfield = initPlayField();\n        this.tetromino = this.getNextTetromino();\n        this.intervalIds = [\n            setInterval(()=>this.loop(), 1000 / fps),\n            setInterval(()=>this.ExecuteKeyStroke(), 1000 / (fps * 2))\n        ];\n        return this;\n    }\n    stopGame() {\n        if (this.intervalIds[0] != -1) return -1;\n        this.intervalIds.forEach((id)=>clearInterval(id));\n    }\n    appendSequence(sequence) {\n        this.tetrominoSequence = [\n            ...this.tetrominoSequence,\n            ...sequence\n        ];\n    }\n    getNextTetromino() {\n        if (this.tetrominoSequence.length === 0) {\n            this.tetrominoDispenser.dispense();\n        }\n        const name = this.tetrominoSequence.pop();\n        const matrix = this.tetrominos[name];\n        const col = this.playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);\n        const row = name === \"I\" ? -1 : -2;\n        return {\n            name: name,\n            matrix: matrix,\n            row: row,\n            col: col\n        };\n    }\n    // rotate an NxN matrix 90deg\n    // @see https://codereview.stackexchange.com/a/186834\n    rotate(matrix) {\n        const N = matrix.length - 1;\n        const result = matrix.map((row, i)=>row.map((val, j)=>matrix[N - j][i]));\n        return result;\n    }\n    // check to see if the new matrix/row/col is valid\n    isValidMove(matrix, cellRow, cellCol) {\n        for(let row = 0; row < matrix.length; row++){\n            for(let col = 0; col < matrix[row].length; col++){\n                if (matrix[row][col] && // outside the game bounds\n                (cellCol + col < 0 || cellCol + col >= this.playfield[0].length || cellRow + row >= this.playfield.length || // collides with another piece\n                this.playfield[cellRow + row][cellCol + col])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    placetetromino() {\n        for(let row = 0; row < this.tetromino.matrix.length; row++){\n            for(let col = 0; col < this.tetromino.matrix[row].length; col++){\n                if (this.tetromino.matrix[row][col]) {\n                    // game over if piece has any part offscreen\n                    if (this.tetromino.row + row < 0) {\n                        this.stopGame();\n                        return this.onGameOver();\n                    }\n                    this.playfield[this.tetromino.row + row][this.tetromino.col + col] = this.tetromino.name;\n                }\n            }\n        }\n        // check for line clears starting from the bottom and working our way up\n        for(let row = this.playfield.length - 1; row >= 0;){\n            if (this.playfield[row].every((cell)=>!!cell)) {\n                // drop every row above this one\n                for(let r = row; r >= 0; r--){\n                    for(let c = 0; c < this.playfield[r].length; c++){\n                        this.playfield[r][c] = this.playfield[r - 1][c];\n                    }\n                }\n            } else {\n                row--;\n            }\n        }\n        this.tetromino = this.getNextTetromino();\n    }\n    loop() {\n        this.onTick();\n        // draw the this.playfield\n        for(let row = 0; row < 20; row++){\n            for(let col = 0; col < 10; col++){\n                if (this.playfield[row][col]) {\n                    const name = this.playfield[row][col];\n                    // drawing 1 px smaller than the grid creates a grid effect\n                    this.onDrawing({\n                        row: row + 1,\n                        col: col + 1,\n                        color: colors[name]\n                    });\n                }\n            }\n        }\n        // draw the active this.tetromino\n        if (this.tetromino) {\n            // console.log(\"!draw\" + JSON.stringify(this.tetromino));\n            // this.tetromino falls every 35 frames\n            if (++this.count > 35) {\n                this.tetromino.row++;\n                this.count = 0;\n                // place piece if it runs into anything\n                if (!this.isValidMove(this.tetromino.matrix, this.tetromino.row, this.tetromino.col)) {\n                    this.tetromino.row--;\n                    this.placetetromino();\n                }\n            }\n            function isHidden(row, col) {\n                // Define the grid boundaries\n                const minRow = 0;\n                const maxRow = 19;\n                const minCol = 0;\n                const maxCol = 9;\n                // Check if the current piece's row and col are outside the boundaries\n                if (row < minRow || row > maxRow || col < minCol || col > maxCol) {\n                    return true;\n                }\n                return false;\n            }\n            function isInsideOfGameGrid(row, col) {\n                // Define the grid boundaries\n                const minRow = 0;\n                const maxRow = 19; // As the grid's height is 20\n                const minCol = 0;\n                const maxCol = 9; // As the grid's width is 10\n                // Check if the current piece's row and col are inside the boundaries\n                return row >= minRow && row <= maxRow && col >= minCol && col <= maxCol;\n            }\n            for(let row = 0; row < this.tetromino.matrix.length; row++){\n                for(let col = 0; col < this.tetromino.matrix[row].length; col++){\n                    if (this.tetromino.matrix[row][col]) {\n                        const display = isInsideOfGameGrid(this.tetromino.row + row, this.tetromino.col + col);\n                        if (!display) continue;\n                        this.onDrawing({\n                            row: this.tetromino.row + row + 1,\n                            col: this.tetromino.col + col + 1,\n                            color: colors[this.tetromino.name]\n                        });\n                    }\n                }\n            }\n        }\n    }\n    /**\n   * Create a Tetris game.\n   * @param {function} onGameOver - The function to call when the game is over.\n   * @param {function} onDrawing - The function to call when drawing the game.\n   */ constructor(onGameOver, onDrawing, onTick){\n        this.tetrominos = {\n            I: [\n                [\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    1,\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0\n                ],\n                [\n                    0,\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            J: [\n                [\n                    1,\n                    0,\n                    0\n                ],\n                [\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            L: [\n                [\n                    0,\n                    0,\n                    1\n                ],\n                [\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            O: [\n                [\n                    1,\n                    1\n                ],\n                [\n                    1,\n                    1\n                ]\n            ],\n            S: [\n                [\n                    0,\n                    1,\n                    1\n                ],\n                [\n                    1,\n                    1,\n                    0\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            Z: [\n                [\n                    1,\n                    1,\n                    0\n                ],\n                [\n                    0,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            T: [\n                [\n                    0,\n                    1,\n                    0\n                ],\n                [\n                    1,\n                    1,\n                    1\n                ],\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ]\n        };\n        this.keyStroke = [];\n        this.tetrominoSequence = [];\n        this.intervalIds = -1;\n        this.count = 0;\n        console.log(\"++++++++++ Tetris init\");\n        this.onGameOver = onGameOver;\n        this.onDrawing = onDrawing;\n        this.onTick = onTick;\n        return this;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdGV0cmlzL3RldHJpcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDBCQUEwQjtBQUMxQixNQUFNQSxTQUFTO0lBQ2JDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7QUFDTDtBQUVBLE1BQU1DLGdCQUFnQjtJQUNwQixJQUFJQyxTQUFTLEVBQUU7SUFDZixJQUFLLElBQUlDLE1BQU0sQ0FBQyxHQUFHQSxNQUFNLElBQUlBLE1BQU87UUFDbENELE1BQU0sQ0FBQ0MsSUFBSSxHQUFHLEVBQUU7UUFFaEIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU0sSUFBSUEsTUFBTztZQUNqQ0YsTUFBTSxDQUFDQyxJQUFJLENBQUNDLElBQUksR0FBRztRQUNyQjtJQUNGO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBOzs7Q0FHQyxHQUNNLE1BQU1HO0lBU1g7Ozs7O0dBS0MsR0FDREMsYUFBYUMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDckJELE1BQU1FLEtBQUtDLElBQUksQ0FBQ0g7UUFDaEJDLE1BQU1DLEtBQUtFLEtBQUssQ0FBQ0g7UUFFakIsT0FBT0MsS0FBS0UsS0FBSyxDQUFDRixLQUFLRyxNQUFNLEtBQU1KLENBQUFBLE1BQU1ELE1BQU0sTUFBTUE7SUFDdkQ7SUFDQTs7O0dBR0MsR0FDRE0sbUJBQW1CO1FBQ2pCLE1BQU1DLFdBQVc7WUFBQztZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUs7WUFBSztTQUFJO1FBQ3BELElBQUlaLFNBQVMsRUFBRTtRQUVmLE1BQU9ZLFNBQVNDLE1BQU0sQ0FBRTtZQUN0QixNQUFNQyxPQUFPLElBQUksQ0FBQ1YsWUFBWSxDQUFDLEdBQUdRLFNBQVNDLE1BQU0sR0FBRztZQUNwRCxNQUFNRSxPQUFPSCxTQUFTSSxNQUFNLENBQUNGLE1BQU0sRUFBRSxDQUFDLEVBQUU7WUFDeENkLE9BQU9pQixJQUFJLENB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QUNUO29CQUFDO29CQUFHO29CQUFHO2lCQUFFO2FBQ1Y7WUFDREMsR0FBRztnQkFDRDtvQkFBQztvQkFBRztvQkFBRztpQkFBRTtnQkFDVDtvQkFBQztvQkFBRztvQkFBRztpQkFBRTtnQkFDVDtvQkFBQztvQkFBRztvQkFBRztpQkFBRTthQUNWO1lBQ0RMLEdBQUc7Z0JBQ0Q7b0JBQUM7b0JBQUc7aUJBQUU7Z0JBQ047b0JBQUM7b0JBQUc7aUJBQUU7YUFDUDtZQUNERSxHQUFHO2dCQUNEO29CQUFDO29CQUFHO29CQUFHO2lCQUFFO2dCQUNUO29CQUFDO29CQUFHO29CQUFHO2lCQUFFO2dCQUNUO29CQUFDO29CQUFHO29CQUFHO2lCQUFFO2FBQ1Y7WUFDREMsR0FBRztnQkFDRDtvQkFBQztvQkFBRztvQkFBRztpQkFBRTtnQkFDVDtvQkFBQztvQkFBRztvQkFBRztpQkFBRTtnQkFDVDtvQkFBQztvQkFBRztvQkFBRztpQkFBRTthQUNWO1lBQ0RGLEdBQUc7Z0JBQ0Q7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7Z0JBQ1Q7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7Z0JBQ1Q7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7YUFDVjtRQUNIO2FBR0FrQyxZQUFZLEVBQUU7YUFHZHFCLG9CQUFvQixFQUFFO2FBRXRCUixjQUFjLENBQUM7YUFDZnlCLFFBQVE7UUFTTnBDLFFBQVFDLEdBQUcsQ0FBQztRQUNaLElBQUksQ0FBQzJCLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDTSxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0QsTUFBTSxHQUFHQTtRQUNkLE9BQU8sSUFBSTtJQUNiO0FBc09GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvdGV0cmlzL3RldHJpcy5qcz84N2Y2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbG9yIG9mIGVhY2ggdGV0cm9taW5vXG5jb25zdCBjb2xvcnMgPSB7XG4gIEk6IFwiY3lhblwiLFxuICBPOiBcInllbGxvd1wiLFxuICBUOiBcInB1cnBsZVwiLFxuICBTOiBcImdyZWVuXCIsXG4gIFo6IFwicmVkXCIsXG4gIEo6IFwiYmx1ZVwiLFxuICBMOiBcIm9yYW5nZVwiLFxufTtcblxuY29uc3QgaW5pdFBsYXlGaWVsZCA9ICgpID0+IHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCByb3cgPSAtMjsgcm93IDwgMjA7IHJvdysrKSB7XG4gICAgcmVzdWx0W3Jvd10gPSBbXTtcblxuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDEwOyBjb2wrKykge1xuICAgICAgcmVzdWx0W3Jvd11bY29sXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFRldHJvbWlubyBEaXNwZW5zZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBzZXF1ZW5jZSBpcyBnZW5lcmF0ZWQuIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgbmVjZXNzYXJ5IHRvIHN5bmNocm9uaXplIHRldHJvbWlub3MgYmV0d2VlbiB0d28gcGxheWVycy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRldHJvbWlub0Rpc3BlbnNlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXRyb21pbm8gRGlzcGVuc2VyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBzZXF1ZW5jZSBpcyBnZW5lcmF0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gaW50ZWdlci5cbiAgICovXG4gIGdldFJhbmRvbUludChtaW4sIG1heCkge1xuICAgIG1pbiA9IE1hdGguY2VpbChtaW4pO1xuICAgIG1heCA9IE1hdGguZmxvb3IobWF4KTtcblxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHNlcXVlbmNlIG9mIFRldHJvbWlub3MuXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgZ2VuZXJhdGVTZXF1ZW5jZSgpIHtcbiAgICBjb25zdCBzZXF1ZW5jZSA9IFtcIklcIiwgXCJKXCIsIFwiTFwiLCBcIk9cIiwgXCJTXCIsIFwiVFwiLCBcIlpcIl07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKHNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcmFuZCA9IHRoaXMuZ2V0UmFuZG9tSW50KDAsIHNlcXVlbmNlLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgbmFtZSA9IHNlcXVlbmNlLnNwbGljZShyYW5kLCAxKVswXTtcbiAgICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBEaXNwZW5zZSBhIHNlcXVlbmNlIG9mIFRldHJvbWlub3MuXG4gICAqIEByZXR1cm4ge1RldHJvbWlub0Rpc3BlbnNlcn0gVGhlIFRldHJvbWlubyBEaXNwZW5zZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhc3luYyBkaXNwZW5zZSgpIHtcbiAgICBjb25zdCBzZXF1ZW5jZSA9IHRoaXMuZ2VuZXJhdGVTZXF1ZW5jZSgpO1xuICAgIHRoaXMuY2FsbGJhY2soc2VxdWVuY2UpO1xuICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgfVxufVxuXG5jb25zdCBmcHMgPSAzMDtcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVGV0cmlzIGdhbWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkdhbWVPdmVyIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZ2FtZSBpcyBvdmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25EcmF3aW5nIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBkcmF3aW5nIHRoZSBnYW1lLlxuICovXG5leHBvcnQgY2xhc3MgVGV0cmlzIHtcbiAgdGV0cm9taW5vcyA9IHtcbiAgICBJOiBbXG4gICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICBbMSwgMSwgMSwgMV0sXG4gICAgICBbMCwgMCwgMCwgMF0sXG4gICAgICBbMCwgMCwgMCwgMF0sXG4gICAgXSxcbiAgICBKOiBbXG4gICAgICBbMSwgMCwgMF0sXG4gICAgICBbMSwgMSwgMV0sXG4gICAgICBbMCwgMCwgMF0sXG4gICAgXSxcbiAgICBMOiBbXG4gICAgICBbMCwgMCwgMV0sXG4gICAgICBbMSwgMSwgMV0sXG4gICAgICBbMCwgMCwgMF0sXG4gICAgXSxcbiAgICBPOiBbXG4gICAgICBbMSwgMV0sXG4gICAgICBbMSwgMV0sXG4gICAgXSxcbiAgICBTOiBbXG4gICAgICBbMCwgMSwgMV0sXG4gICAgICBbMSwgMSwgMF0sXG4gICAgICBbMCwgMCwgMF0sXG4gICAgXSxcbiAgICBaOiBbXG4gICAgICBbMSwgMSwgMF0sXG4gICAgICBbMCwgMSwgMV0sXG4gICAgICBbMCwgMCwgMF0sXG4gICAgXSxcbiAgICBUOiBbXG4gICAgICBbMCwgMSwgMF0sXG4gICAgICBbMSwgMSwgMV0sXG4gICAgICBbMCwgMCwgMF0sXG4gICAgXSxcbiAgfTtcbiAgb25HYW1lT3ZlcjtcbiAgb25EcmF3aW5nO1xuICBrZXlTdHJva2UgPSBbXTtcbiAgb25UaWNrO1xuICBwbGF5ZmllbGQ7XG4gIHRldHJvbWlub1NlcXVlbmNlID0gW107XG4gIHRldHJvbWlubztcbiAgaW50ZXJ2YWxJZHMgPSAtMTtcbiAgY291bnQgPSAwO1xuICB0ZXRyb21pbm9EaXNwZW5zZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFRldHJpcyBnYW1lLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkdhbWVPdmVyIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZ2FtZSBpcyBvdmVyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbkRyYXdpbmcgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRyYXdpbmcgdGhlIGdhbWUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvbkdhbWVPdmVyLCBvbkRyYXdpbmcsIG9uVGljaykge1xuICAgIGNvbnNvbGUubG9nKFwiKysrKysrKysrKyBUZXRyaXMgaW5pdFwiKTtcbiAgICB0aGlzLm9uR2FtZU92ZXIgPSBvbkdhbWVPdmVyO1xuICAgIHRoaXMub25EcmF3aW5nID0gb25EcmF3aW5nO1xuICAgIHRoaXMub25UaWNrID0gb25UaWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0VGV0cm9taW5vRGlzcGVuc2VyKGRpc3BlbnNlcikge1xuICAgIHRoaXMudGV0cm9taW5vRGlzcGVuc2VyID0gZGlzcGVuc2VyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgUmVnaXN0ZXJLZXlTdHJva2Uoa2V5KSB7XG4gICAgdGhpcy5rZXlTdHJva2UgPSBbLi4udGhpcy5rZXlTdHJva2UsIGtleV07XG4gIH1cblxuICBFeGVjdXRlS2V5U3Ryb2tlKCkge1xuICAgIGlmICghdGhpcy5rZXlTdHJva2UubGVuZ3RoKSByZXR1cm47XG4gICAgY29uc29sZS5sb2coXCJuZWVkIHRvIGV4ZWN1dGVcIiwgdGhpcy5rZXlTdHJva2UpO1xuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5U3Ryb2tlLnBvcCgpO1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICBjb25zdCBjb2wgPVxuICAgICAgICAgIGtleSA9PT0gXCJBcnJvd0xlZnRcIiA/IHRoaXMudGV0cm9taW5vLmNvbCAtIDEgOiB0aGlzLnRldHJvbWluby5jb2wgKyAxO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkTW92ZSh0aGlzLnRldHJvbWluby5tYXRyaXgsIHRoaXMudGV0cm9taW5vLnJvdywgY29sKSkge1xuICAgICAgICAgIHRoaXMudGV0cm9taW5vLmNvbCA9IGNvbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMucm90YXRlKHRoaXMudGV0cm9taW5vLm1hdHJpeCk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRNb3ZlKG1hdHJpeCwgdGhpcy50ZXRyb21pbm8ucm93LCB0aGlzLnRldHJvbWluby5jb2wpKSB7XG4gICAgICAgICAgdGhpcy50ZXRyb21pbm8ubWF0cml4ID0gbWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICBjb25zdCByb3cgPSB0aGlzLnRldHJvbWluby5yb3cgKyAxO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZE1vdmUodGhpcy50ZXRyb21pbm8ubWF0cml4LCByb3csIHRoaXMudGV0cm9taW5vLmNvbCkpIHtcbiAgICAgICAgICB0aGlzLnRldHJvbWluby5yb3cgPSByb3cgLSAxO1xuICAgICAgICAgIHRoaXMucGxhY2V0ZXRyb21pbm8oKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXRyb21pbm8ucm93ID0gcm93O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhcImV4ZWN1dGUga2V5OiBcIiArIGtleSk7XG4gIH1cblxuICBzdGFydEdhbWUoKSB7XG4gICAgdGhpcy5wbGF5ZmllbGQgPSBpbml0UGxheUZpZWxkKCk7XG4gICAgdGhpcy50ZXRyb21pbm8gPSB0aGlzLmdldE5leHRUZXRyb21pbm8oKTtcbiAgICB0aGlzLmludGVydmFsSWRzID0gW1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5sb29wKCksIDEwMDAgLyBmcHMpLFxuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5FeGVjdXRlS2V5U3Ryb2tlKCksIDEwMDAgLyAoZnBzICogMikpLFxuICAgIF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RvcEdhbWUoKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWxJZHNbMF0gIT0gLTEpIHJldHVybiAtMTtcbiAgICB0aGlzLmludGVydmFsSWRzLmZvckVhY2goKGlkKSA9PiBjbGVhckludGVydmFsKGlkKSk7XG4gIH1cblxuICBhcHBlbmRTZXF1ZW5jZShzZXF1ZW5jZSkge1xuICAgIHRoaXMudGV0cm9taW5vU2VxdWVuY2UgPSBbLi4udGhpcy50ZXRyb21pbm9TZXF1ZW5jZSwgLi4uc2VxdWVuY2VdO1xuICB9XG5cbiAgZ2V0TmV4dFRldHJvbWlubygpIHtcbiAgICBpZiAodGhpcy50ZXRyb21pbm9TZXF1ZW5jZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudGV0cm9taW5vRGlzcGVuc2VyLmRpc3BlbnNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHRoaXMudGV0cm9taW5vU2VxdWVuY2UucG9wKCk7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy50ZXRyb21pbm9zW25hbWVdO1xuXG4gICAgY29uc3QgY29sID0gdGhpcy5wbGF5ZmllbGRbMF0ubGVuZ3RoIC8gMiAtIE1hdGguY2VpbChtYXRyaXhbMF0ubGVuZ3RoIC8gMik7XG5cbiAgICBjb25zdCByb3cgPSBuYW1lID09PSBcIklcIiA/IC0xIDogLTI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgcm93OiByb3csXG4gICAgICBjb2w6IGNvbCxcbiAgICB9O1xuICB9XG5cbiAgLy8gcm90YXRlIGFuIE54TiBtYXRyaXggOTBkZWdcbiAgLy8gQHNlZSBodHRwczovL2NvZGVyZXZpZXcuc3RhY2tleGNoYW5nZS5jb20vYS8xODY4MzRcbiAgcm90YXRlKG1hdHJpeCkge1xuICAgIGNvbnN0IE4gPSBtYXRyaXgubGVuZ3RoIC0gMTtcbiAgICBjb25zdCByZXN1bHQgPSBtYXRyaXgubWFwKChyb3csIGkpID0+XG4gICAgICByb3cubWFwKCh2YWwsIGopID0+IG1hdHJpeFtOIC0gal1baV0pXG4gICAgKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIG5ldyBtYXRyaXgvcm93L2NvbCBpcyB2YWxpZFxuICBpc1ZhbGlkTW92ZShtYXRyaXgsIGNlbGxSb3csIGNlbGxDb2wpIHtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXRyaXgubGVuZ3RoOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgbWF0cml4W3Jvd10ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbWF0cml4W3Jvd11bY29sXSAmJlxuICAgICAgICAgIC8vIG91dHNpZGUgdGhlIGdhbWUgYm91bmRzXG4gICAgICAgICAgKGNlbGxDb2wgKyBjb2wgPCAwIHx8XG4gICAgICAgICAgICBjZWxsQ29sICsgY29sID49IHRoaXMucGxheWZpZWxkWzBdLmxlbmd0aCB8fFxuICAgICAgICAgICAgY2VsbFJvdyArIHJvdyA+PSB0aGlzLnBsYXlmaWVsZC5sZW5ndGggfHxcbiAgICAgICAgICAgIC8vIGNvbGxpZGVzIHdpdGggYW5vdGhlciBwaWVjZVxuICAgICAgICAgICAgdGhpcy5wbGF5ZmllbGRbY2VsbFJvdyArIHJvd11bY2VsbENvbCArIGNvbF0pXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcGxhY2V0ZXRyb21pbm8oKSB7XG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy50ZXRyb21pbm8ubWF0cml4Lmxlbmd0aDsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMudGV0cm9taW5vLm1hdHJpeFtyb3ddLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgaWYgKHRoaXMudGV0cm9taW5vLm1hdHJpeFtyb3ddW2NvbF0pIHtcbiAgICAgICAgICAvLyBnYW1lIG92ZXIgaWYgcGllY2UgaGFzIGFueSBwYXJ0IG9mZnNjcmVlblxuICAgICAgICAgIGlmICh0aGlzLnRldHJvbWluby5yb3cgKyByb3cgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BHYW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbkdhbWVPdmVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5wbGF5ZmllbGRbdGhpcy50ZXRyb21pbm8ucm93ICsgcm93XVt0aGlzLnRldHJvbWluby5jb2wgKyBjb2xdID1cbiAgICAgICAgICAgIHRoaXMudGV0cm9taW5vLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgbGluZSBjbGVhcnMgc3RhcnRpbmcgZnJvbSB0aGUgYm90dG9tIGFuZCB3b3JraW5nIG91ciB3YXkgdXBcbiAgICBmb3IgKGxldCByb3cgPSB0aGlzLnBsYXlmaWVsZC5sZW5ndGggLSAxOyByb3cgPj0gMDsgKSB7XG4gICAgICBpZiAodGhpcy5wbGF5ZmllbGRbcm93XS5ldmVyeSgoY2VsbCkgPT4gISFjZWxsKSkge1xuICAgICAgICAvLyBkcm9wIGV2ZXJ5IHJvdyBhYm92ZSB0aGlzIG9uZVxuICAgICAgICBmb3IgKGxldCByID0gcm93OyByID49IDA7IHItLSkge1xuICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5wbGF5ZmllbGRbcl0ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHRoaXMucGxheWZpZWxkW3JdW2NdID0gdGhpcy5wbGF5ZmllbGRbciAtIDFdW2NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93LS07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGV0cm9taW5vID0gdGhpcy5nZXROZXh0VGV0cm9taW5vKCk7XG4gIH1cblxuICBsb29wKCkge1xuICAgIHRoaXMub25UaWNrKCk7XG4gICAgLy8gZHJhdyB0aGUgdGhpcy5wbGF5ZmllbGRcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCAyMDsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDEwOyBjb2wrKykge1xuICAgICAgICBpZiAodGhpcy5wbGF5ZmllbGRbcm93XVtjb2xdKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMucGxheWZpZWxkW3Jvd11bY29sXTtcblxuICAgICAgICAgIC8vIGRyYXdpbmcgMSBweCBzbWFsbGVyIHRoYW4gdGhlIGdyaWQgY3JlYXRlcyBhIGdyaWQgZWZmZWN0XG4gICAgICAgICAgdGhpcy5vbkRyYXdpbmcoe1xuICAgICAgICAgICAgcm93OiByb3cgKyAxLFxuICAgICAgICAgICAgY29sOiBjb2wgKyAxLFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tuYW1lXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyYXcgdGhlIGFjdGl2ZSB0aGlzLnRldHJvbWlub1xuICAgIGlmICh0aGlzLnRldHJvbWlubykge1xuICAgICAgLy8gY29uc29sZS5sb2coXCIhZHJhd1wiICsgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXRyb21pbm8pKTtcbiAgICAgIC8vIHRoaXMudGV0cm9taW5vIGZhbGxzIGV2ZXJ5IDM1IGZyYW1lc1xuICAgICAgaWYgKCsrdGhpcy5jb3VudCA+IDM1KSB7XG4gICAgICAgIHRoaXMudGV0cm9taW5vLnJvdysrO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcblxuICAgICAgICAvLyBwbGFjZSBwaWVjZSBpZiBpdCBydW5zIGludG8gYW55dGhpbmdcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF0aGlzLmlzVmFsaWRNb3ZlKFxuICAgICAgICAgICAgdGhpcy50ZXRyb21pbm8ubWF0cml4LFxuICAgICAgICAgICAgdGhpcy50ZXRyb21pbm8ucm93LFxuICAgICAgICAgICAgdGhpcy50ZXRyb21pbm8uY29sXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLnRldHJvbWluby5yb3ctLTtcbiAgICAgICAgICB0aGlzLnBsYWNldGV0cm9taW5vKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNIaWRkZW4ocm93LCBjb2wpIHtcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBncmlkIGJvdW5kYXJpZXNcbiAgICAgICAgY29uc3QgbWluUm93ID0gMDtcbiAgICAgICAgY29uc3QgbWF4Um93ID0gMTk7XG4gICAgICAgIGNvbnN0IG1pbkNvbCA9IDA7XG4gICAgICAgIGNvbnN0IG1heENvbCA9IDk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgcGllY2UncyByb3cgYW5kIGNvbCBhcmUgb3V0c2lkZSB0aGUgYm91bmRhcmllc1xuICAgICAgICBpZiAocm93IDwgbWluUm93IHx8IHJvdyA+IG1heFJvdyB8fCBjb2wgPCBtaW5Db2wgfHwgY29sID4gbWF4Q29sKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSW5zaWRlT2ZHYW1lR3JpZChyb3csIGNvbCkge1xuICAgICAgICAvLyBEZWZpbmUgdGhlIGdyaWQgYm91bmRhcmllc1xuICAgICAgICBjb25zdCBtaW5Sb3cgPSAwO1xuICAgICAgICBjb25zdCBtYXhSb3cgPSAxOTsgLy8gQXMgdGhlIGdyaWQncyBoZWlnaHQgaXMgMjBcbiAgICAgICAgY29uc3QgbWluQ29sID0gMDtcbiAgICAgICAgY29uc3QgbWF4Q29sID0gOTsgLy8gQXMgdGhlIGdyaWQncyB3aWR0aCBpcyAxMFxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHBpZWNlJ3Mgcm93IGFuZCBjb2wgYXJlIGluc2lkZSB0aGUgYm91bmRhcmllc1xuICAgICAgICByZXR1cm4gcm93ID49IG1pblJvdyAmJiByb3cgPD0gbWF4Um93ICYmIGNvbCA+PSBtaW5Db2wgJiYgY29sIDw9IG1heENvbDtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy50ZXRyb21pbm8ubWF0cml4Lmxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy50ZXRyb21pbm8ubWF0cml4W3Jvd10ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgIGlmICh0aGlzLnRldHJvbWluby5tYXRyaXhbcm93XVtjb2xdKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5ID0gaXNJbnNpZGVPZkdhbWVHcmlkKFxuICAgICAgICAgICAgICB0aGlzLnRldHJvbWluby5yb3cgKyByb3csXG4gICAgICAgICAgICAgIHRoaXMudGV0cm9taW5vLmNvbCArIGNvbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghZGlzcGxheSkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzLm9uRHJhd2luZyh7XG4gICAgICAgICAgICAgIHJvdzogdGhpcy50ZXRyb21pbm8ucm93ICsgcm93ICsgMSxcbiAgICAgICAgICAgICAgY29sOiB0aGlzLnRldHJvbWluby5jb2wgKyBjb2wgKyAxLFxuICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW3RoaXMudGV0cm9taW5vLm5hbWVdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiY29sb3JzIiwiSSIsIk8iLCJUIiwiUyIsIloiLCJKIiwiTCIsImluaXRQbGF5RmllbGQiLCJyZXN1bHQiLCJyb3ciLCJjb2wiLCJUZXRyb21pbm9EaXNwZW5zZXIiLCJnZXRSYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJNYXRoIiwiY2VpbCIsImZsb29yIiwicmFuZG9tIiwiZ2VuZXJhdGVTZXF1ZW5jZSIsInNlcXVlbmNlIiwibGVuZ3RoIiwicmFuZCIsIm5hbWUiLCJzcGxpY2UiLCJwdXNoIiwiZGlzcGVuc2UiLCJjYWxsYmFjayIsImNvbnN0cnVjdG9yIiwiZnBzIiwiVGV0cmlzIiwic2V0VGV0cm9taW5vRGlzcGVuc2VyIiwiZGlzcGVuc2VyIiwidGV0cm9taW5vRGlzcGVuc2VyIiwiUmVnaXN0ZXJLZXlTdHJva2UiLCJrZXkiLCJrZXlTdHJva2UiLCJFeGVjdXRlS2V5U3Ryb2tlIiwiY29uc29sZSIsImxvZyIsInBvcCIsInRldHJvbWlubyIsImlzVmFsaWRNb3ZlIiwibWF0cml4Iiwicm90YXRlIiwicGxhY2V0ZXRyb21pbm8iLCJzdGFydEdhbWUiLCJwbGF5ZmllbGQiLCJnZXROZXh0VGV0cm9taW5vIiwiaW50ZXJ2YWxJZHMiLCJzZXRJbnRlcnZhbCIsImxvb3AiLCJzdG9wR2FtZSIsImZvckVhY2giLCJpZCIsImNsZWFySW50ZXJ2YWwiLCJhcHBlbmRTZXF1ZW5jZSIsInRldHJvbWlub1NlcXVlbmNlIiwidGV0cm9taW5vcyIsIk4iLCJtYXAiLCJpIiwidmFsIiwiaiIsImNlbGxSb3ciLCJjZWxsQ29sIiwib25HYW1lT3ZlciIsImV2ZXJ5IiwiY2VsbCIsInIiLCJjIiwib25UaWNrIiwib25EcmF3aW5nIiwiY29sb3IiLCJjb3VudCIsImlzSGlkZGVuIiwibWluUm93IiwibWF4Um93IiwibWluQ29sIiwibWF4Q29sIiwiaXNJbnNpZGVPZkdhbWVHcmlkIiwiZGlzcGxheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/tetris/tetris.js\n"));

/***/ })

});